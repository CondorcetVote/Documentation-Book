# Advanced Results

## Get metadata from Result object

::: tip Reference
[`Result->byClass`](/api-reference/Result%20Class/Result--byClass) 
[`Result->fromMethod`](/api-reference/Result%20Class/Result--fromMethod) 
[`Result->electionCondorcetVersion`](/api-reference/Result%20Class/Result--electionCondorcetVersion) 
[`Result->buildTimestamp`](/api-reference/Result%20Class/Result--buildTimestamp)  
:::
```php
$election->getResult('Schulze');

$result->byClass; // Namespace of the Schulze module. Like 'CondorcetPHP\Condorcet\Algo\Methods\SchulzeWinning'
$result->fromMethod; // Method who build this result. Like 'Schulze'.
$result->electionCondorcetVersion; // Condorcet version at the build time.
$result->buildTimestamp; // Return timestamp (float) of the build time.
```

## Get compute details

::: tip Reference
[`Result->pairwise`](/api-reference/Result%20Class/Result--pairwise) 
[`Result->ranking`](/api-reference/Result%20Class/Result--ranking)
[`Result->stats`](/api-reference/Result%20Class/Result--stats)
:::
```php
$election->ranking; // An explicit array using your Candidate Name as keys.  
$election->getResult('Schulze')->stats; // Stats about computing result for the default object method.
```

## Get result infos

<!-- tabs:start -->
### **Classical**
::: info
`Candidate` object are not immutable, and a candidate can change his name at any moment. Despite that the history is keeped: if you play with that powerful but dangerous simulations tools, result object can produce surprising results if your are not vigilant. If you follow a simpler use, you don't care.  
More information on the [**Mutability chapter**](/book/3.AsPhpLibrary/8.GoFurther/6.Mutability).
:::

::: tip Reference
[`Result->Winner`](/api-reference/Result%20Class/Result--Winner) 
[`Result->Loser`](/api-reference/Result%20Class/Result--Loser) 
[`Result->CondorcetWinner`](/api-reference/Result%20Class/Result--CondorcetWinner) 
[`Result->CondorcetLoser`](/api-reference/Result%20Class/Result--CondorcetLoser) 
[`Result->rankingAsArrayString`](/api-reference/Result%20Class/Result--rankingAsArrayString)
[`Result->ranking`](/api-reference/Result%20Class/Result--ranking)
:::
```php
$election->getResult('Schulze')->CondorcetWinner; // Equivalent to $election->getWinner('Schulze');
$election->getResult('Schulze')->CondorcetLoser; // Equivalent to $election->getLoser('Schulze');

$election->getResult('Schulze')->CondorcetWinner ; // Get the condorcet winner from the parent election at the build time (can became different. This one never change) or null if he don't exist.
$election->getResult('Schulze')->CondorcetLoser ; // Get the condorcet loser from the parent election at the build time (can became different. This one never change) or null if he don't exist.

$election->getResult('Schulze')->ranking ; // Return Result ranking as array. So, the original Result object is iterable, support array access and count... Why doing that ?
$election->getResult('Schulze')->rankingAsArrayString ; // Same thing. But more: that convert Candidate object into string by name.
```

### **Strictly immutable**
::: info
These two methods are strictly immutable, and provide string name at the moment of the creation of the result object.
:::

::: tip Reference
[`Result->originalRankingAsArrayString`](/api-reference/Result%20Class/Result--originalRankingAsArrayString) 
[`Result->originalRankingAsString()`](/api-reference/Result%20Class/Result--originalRankingAsString)  
:::
```php
$result->originalRankingAsArrayString; // Return the result as array with Candidate as string by name. because Candidate name can continue to change (Even if you can get the history of the changes.). This method give you serenity.
$result->originalRankingAsString; // Return a string like "A > B = C > D > E > G = H"
```
<!-- tabs:end -->


